<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Call History Editor — Fixed Template</title>
  <style>
    body{font-family:-apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial;margin:18px;background:#f6f7fb;color:#111}
    h1{font-size:18px;margin:0 0 10px}
    .wrap{display:flex;gap:18px;align-items:flex-start}
    .panel{background:white;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,50,0.06);width:340px}
    label{display:block;font-size:13px;margin-top:8px}
    input[type=text]{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #e0e6ef}
    button{margin-top:8px;padding:8px 10px;border-radius:8px;border:0;background:#0b76ff;color:white;cursor:pointer}
    button.secondary{background:#666}
    .canvas-wrap{background:white;padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,50,0.06)}
    canvas{border:1px solid #ddd;max-width:800px;width:100%;height:auto}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h1>Call History Editor (Fixed)</h1>
  <div class="wrap">
    <div class="panel">
      <label>Nhập số điện thoại</label>
      <input id="phoneInput" type="text" placeholder="Số điện thoại (ví dụ +84...)" />

      <label>Nhập thời lượng</label>
      <input id="durationInput" type="text" placeholder="Ví dụ: 2m hoặc 120s" />

      <label><input id="blurToggle" type="checkbox" /> Blur số điện thoại (chỉ để lại 3 số cuối)</label>

      <button id="createBtn">Tạo (thời gian realtime)</button>
      <button id="downloadBtn" class="secondary">Tải về</button>

      <div style="margin-top:10px">
        <div class="small">Thời gian sẽ lấy lúc bạn bấm "Tạo" (HH:MM).<br>
        Nếu bật Blur SĐT: chỉ để rõ 3 số cuối, phần còn lại sẽ mờ.</div>
      </div>
    </div>

    <div class="canvas-wrap">
      <strong>Preview</strong>
      <canvas id="c" width="591" height="1225"></canvas>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ===== UI elements
  const blurToggle = document.getElementById('blurToggle');
  const calibToggle = document.getElementById('calibToggle');
  const activeField = document.getElementById('activeField');
  const fontSize = document.getElementById('fontSize');
  const alignSel = document.getElementById('alignSel');
  const coordsEl = document.getElementById('coords');

  // ===== Config (center anchors)
  const cfg = {
    phone:   { x: 296, y: 395, font: 36, align: 'center' },
    time:    { x: 70,  y: 662, font: 17, align: 'left',  bold: true },
    duration:{ x: 520, y: 662, font: 17, align: 'right' }
  };
  try { const saved = JSON.parse(localStorage.getItem('call_cfg')); if(saved) Object.assign(cfg, saved); } catch{}

  let img = new Image();
  img.src = 'background.jpg';
  img.onload = ()=>{ redraw(); updateUIFromCfg(); };

  function setFont(size, bold=false){
    ctx.font = (bold? "600 ": "") + size + 'px -apple-system, BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Arial';
    ctx.fillStyle = '#000';
    ctx.textBaseline = 'middle';
  }
  function drawText(text, pt, size, align='left', bold=false){
    setFont(size, bold);
    ctx.textAlign = align;
    ctx.fillText(text, pt.x, pt.y);
  }

  function redraw(phoneText, durationText, blur, showGuides=false){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);

    // PHONE
    if(phoneText){
      if(blur){
        const areaW = 560, areaH = 70; // approximate area for blur
        const off = document.createElement('canvas');
        off.width = areaW; off.height = areaH;
        const octx = off.getContext('2d');
        octx.textBaseline = 'middle';
        octx.textAlign = cfg.phone.align;
        octx.font = cfg.phone.font + 'px -apple-system, BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Arial';
        octx.fillStyle = '#000';
        const ox = cfg.phone.align==='center' ? areaW/2 : cfg.phone.align==='right' ? areaW-10 : 10;
        octx.fillText(phoneText, ox, areaH/2);
        const blurC = document.createElement('canvas');
        blurC.width = areaW; blurC.height = areaH;
        const bctx = blurC.getContext('2d');
        bctx.filter = 'blur(6px)';
        bctx.drawImage(off,0,0);
        ctx.drawImage(blurC, cfg.phone.x - (cfg.phone.align==='center'? areaW/2 : cfg.phone.align==='right'? areaW-10 : 10), cfg.phone.y - areaH/2);
        // last 3 clear
        const last3 = phoneText.slice(-3);
        drawText(last3, {x: cfg.phone.x + (cfg.phone.align==='right'? -10: (cfg.phone.align==='center'?  areaW/2-10 : areaW-20)) , y: cfg.phone.y}, cfg.phone.font, 'right');
      } else {
        drawText(phoneText, {x: cfg.phone.x, y: cfg.phone.y}, cfg.phone.font, cfg.phone.align);
      }
    }

    // TIME realtime
    const now = new Date();
    const HH = String(now.getHours()).padStart(2,'0');
    const MM = String(now.getMinutes()).padStart(2,'0');
    const timeText = HH+":"+MM;
    drawText(timeText, {x: cfg.time.x, y: cfg.time.y}, cfg.time.font, cfg.time.align, cfg.time.bold);

    // DURATION
    if(durationText){
      drawText(durationText, {x: cfg.duration.x, y: cfg.duration.y}, cfg.duration.font, cfg.duration.align);
    }

    // Guides for calibration
    if(showGuides){
      ['phone','time','duration'].forEach(k=>{
        const p = cfg[k];
        ctx.save();
        ctx.strokeStyle = k==='phone'? '#ef4444' : k==='time'? '#3b82f6' : '#10b981';
        ctx.setLineDash([5,4]);
        ctx.beginPath();
        ctx.moveTo(p.x-12, p.y); ctx.lineTo(p.x+12, p.y);
        ctx.moveTo(p.x, p.y-12); ctx.lineTo(p.x, p.y+12);
        ctx.stroke();
        ctx.restore();
      });
    }
  }

  function updateUIFromCfg(){
    const key = activeField.value;
    fontSize.value = cfg[key].font;
    alignSel.value = cfg[key].align || 'left';
  }
  function saveCfg(){ localStorage.setItem('call_cfg', JSON.stringify(cfg)); }

  // ===== Calibrate interactions
  canvas.addEventListener('mousemove', (e)=>{
    if(!calibToggle.checked) return;
    const r = canvas.getBoundingClientRect();
    const x = Math.round(e.clientX - r.left), y = Math.round(e.clientY - r.top);
    coordsEl.textContent = `Tọa độ: (${x}, ${y})`;
  });
  canvas.addEventListener('click', (e)=>{
    if(!calibToggle.checked) return;
    const r = canvas.getBoundingClientRect();
    const x = Math.round(e.clientX - r.left), y = Math.round(e.clientY - r.top);
    const key = activeField.value; cfg[key].x = x; cfg[key].y = y; saveCfg();
    redraw(document.getElementById('phoneInput').value.trim(), document.getElementById('durationInput').value.trim(), blurToggle.checked, true);
    updateUIFromCfg();
  });
  window.addEventListener('keydown', (e)=>{
    if(!calibToggle.checked) return;
    const key = activeField.value; const step = e.shiftKey? 10 : 1;
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
      e.preventDefault();
      if(e.key==='ArrowUp') cfg[key].y -= step;
      if(e.key==='ArrowDown') cfg[key].y += step;
      if(e.key==='ArrowLeft') cfg[key].x -= step;
      if(e.key==='ArrowRight') cfg[key].x += step;
      saveCfg();
      redraw(document.getElementById('phoneInput').value.trim(), document.getElementById('durationInput').value.trim(), blurToggle.checked, true);
      coordsEl.textContent = `Tọa độ: (${cfg[key].x}, ${cfg[key].y})`;
    }
    if(/^[1-9]$/.test(e.key)){
      cfg[key].font = 10 * parseInt(e.key); saveCfg(); updateUIFromCfg();
      redraw(document.getElementById('phoneInput').value.trim(), document.getElementById('durationInput').value.trim(), blurToggle.checked, true);
    }
  });
  activeField.addEventListener('change', updateUIFromCfg);
  fontSize.addEventListener('change', ()=>{ cfg[activeField.value].font = parseInt(fontSize.value)||cfg[activeField.value].font; saveCfg(); redraw(document.getElementById('phoneInput').value.trim(), document.getElementById('durationInput').value.trim(), blurToggle.checked, calibToggle.checked); });
  alignSel.addEventListener('change', ()=>{ cfg[activeField.value].align = alignSel.value; saveCfg(); redraw(document.getElementById('phoneInput').value.trim(), document.getElementById('durationInput').value.trim(), blurToggle.checked, calibToggle.checked); });
  document.getElementById('copyCfg').addEventListener('click', ()=>{
    const text = JSON.stringify(cfg, null, 2);
    navigator.clipboard.writeText(text).then(()=>{ alert('Đã copy config vào clipboard'); });
  });

  // ===== Actions
  document.getElementById('createBtn').addEventListener('click', ()=>{
    const phone = document.getElementById('phoneInput').value.trim();
    const dur = document.getElementById('durationInput').value.trim();
    redraw(phone, dur, blurToggle.checked, calibToggle.checked);
    window._lastGenerated = canvas;
  });

  document.getElementById('downloadBtn').addEventListener('click', ()=>{
    const fc = window._lastGenerated || canvas;
    const a = document.createElement('a');
    a.href = fc.toDataURL('image/png');
    a.download = 'call_history_fixed.png';
    a.click();
  });
})();
</script>
</body>
</html>
